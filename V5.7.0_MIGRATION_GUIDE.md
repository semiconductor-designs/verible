# Verible v5.7.0 Migration Guide

**Target Audience**: Users upgrading from v5.6.0 to v5.7.0  
**Difficulty**: Easy (backward compatible)  
**Time Required**: 10-30 minutes

---

## üìã Quick Start

### Do I Need to Migrate?

**Short Answer**: Probably not!

v5.7.0 is **100% backward compatible** with v5.6.0. If you're not using custom JSON parsing, you can upgrade with zero changes.

**Check if you need action**:
- ‚úÖ Using `--export_json` without parsing? ‚Üí **No action needed**
- ‚úÖ Parsing JSON output? ‚Üí **Minor update** (see Section 2)
- ‚úÖ Want new features (`--export_indexed_json`, `--continue_on_error`)? ‚Üí **Opt-in** (see Section 3)

---

## 1. Standard Upgrade (No Code Changes)

### Step 1: Update Verible Binary

```bash
# Option A: Build from source
git fetch
git checkout v5.7.0
bazel build -c opt //verible/verilog/tools/syntax:verible-verilog-syntax

# Option B: Download release binary
# (Download from release page)
```

### Step 2: Verify Version

```bash
./verible-verilog-syntax --version
# Expected output: v5.7.0-...
```

### Step 3: Test with Existing Workflows

```bash
# Run your existing commands
./verible-verilog-syntax --export_json myfile.sv

# Output format is backward compatible (just adds metadata)
```

**That's it!** Your existing workflows continue to work.

---

## 2. Update JSON Parsers (If Applicable)

If your code parses Verible's JSON output, make this small update:

### Before (v5.6.0)

```python
import json

with open("output.json") as f:
    data = json.load(f)

# Directly access file data
file_data = data["myfile.sv"]
tree = file_data["tree"]
```

### After (v5.7.0) - Recommended

```python
import json

with open("output.json") as f:
    data = json.load(f)

# NEW: Skip version metadata fields (optional but recommended)
METADATA_FIELDS = {
    "verible_version",
    "cst_schema_version",
    "export_format",
    "timestamp"
}

file_keys = [k for k in data.keys() if k not in METADATA_FIELDS]

for file_key in file_keys:
    file_data = data[file_key]
    tree = file_data.get("tree")  # May be None if parse failed
    status = file_data.get("status", "unknown")  # NEW in v5.7.0
    
    if status == "success":
        process_tree(tree)
```

### Alternative: Check Version First

```python
# Robust version checking
data = json.load(f)

if "verible_version" in data:
    # v5.7.0+ format
    version = data["verible_version"]
    schema = data.get("cst_schema_version", "unknown")
    
    if schema != "1.0":
        raise ValueError(f"Unsupported CST schema: {schema}")

# Rest of code works the same
file_data = data["myfile.sv"]
```

---

## 3. Adopt New Features (Opt-In)

### Feature 1: Indexed JSON Export

**Use Case**: Processing multiple files, need file index mapping

**Migration Steps**:

**Old Command (v5.6.0)**:
```bash
verible-verilog-syntax --export_json file1.sv file2.sv file3.sv > output.json
```

**New Command (v5.7.0)**:
```bash
verible-verilog-syntax --export_indexed_json file1.sv file2.sv file3.sv > output.json
```

**Update Parser**:
```python
# v5.7.0 indexed JSON structure
data = json.load(f)

# NEW: file_index mapping
file_index = data["file_index"]
# {"0": "/abs/path/file1.sv", "1": "/abs/path/file2.sv", "2": ...}

# NEW: CSTs under "cst" key
cst_data = data["cst"]
# {"/abs/path/file1.sv": {"tree": ..., "status": "success"}, ...}

for filename, file_info in cst_data.items():
    status = file_info["status"]
    if status == "success":
        tree = file_info["tree"]
        # Process tree...
```

**Resolve `<indexed>:N` References**:
```python
# If CST node contains:
# {"file": "<indexed>:0"}

def resolve_indexed_file(ref, file_index):
    """Resolve <indexed>:N to actual path"""
    if ref.startswith("<indexed>:"):
        index_id = ref.split(":")[1]
        return file_index[index_id]
    return ref

# Usage
file_ref = node.get("file")
actual_path = resolve_indexed_file(file_ref, file_index)
```

---

### Feature 2: Continue-on-Error

**Use Case**: Batch processing large repositories, don't stop on errors

**Migration Steps**:

**Old Behavior (v5.6.0)**:
```bash
# Stops on first error
verible-verilog-syntax --export_json *.sv
# Only files before error are processed
```

**New Behavior (v5.7.0)**:
```bash
# Processes all files
verible-verilog-syntax --continue_on_error --export_json *.sv
# Exit code: 1 if any errors, 0 if all succeeded
```

**Update Error Handling**:
```python
# Check per-file status
for filename, file_data in data.items():
    if filename in METADATA_FIELDS:
        continue
    
    status = file_data.get("status")
    
    if status == "success":
        # File parsed successfully
        tree = file_data["tree"]
        process_success(tree)
    
    elif status == "failed":
        # File failed to parse
        errors = file_data.get("errors", [])
        tree_status = file_data.get("tree_status")  # "partial" or "none"
        
        if tree_status == "partial":
            # Partial CST available
            partial_tree = file_data.get("partial_tree")
            process_partial(partial_tree, errors)
        else:
            # Complete failure, no CST
            log_error(filename, errors)
```

---

### Feature 3: Schema Validation

**Use Case**: Ensure CST format compatibility

**Migration Steps**:

**Add Version Check**:
```python
def validate_verible_output(data):
    """Validate Verible JSON output version"""
    
    # Check for version metadata
    if "verible_version" not in data:
        print("Warning: No version metadata (pre-v5.7.0 output)")
        return True  # Old format, best-effort parsing
    
    # Check schema version
    schema_version = data.get("cst_schema_version")
    supported_versions = ["1.0"]
    
    if schema_version not in supported_versions:
        raise ValueError(
            f"Unsupported CST schema version: {schema_version}. "
            f"Supported: {supported_versions}"
        )
    
    # Check format
    export_format = data.get("export_format", "standard")
    if export_format not in ["standard", "indexed"]:
        raise ValueError(f"Unknown export format: {export_format}")
    
    return True

# Usage
data = json.load(f)
validate_verible_output(data)
# Proceed with confidence...
```

---

## 4. Common Migration Patterns

### Pattern 1: Batch Processing Script

**Before (v5.6.0)**:
```bash
#!/bin/bash
for file in *.sv; do
    verible-verilog-syntax --export_json "$file" > "${file}.json"
    if [ $? -ne 0 ]; then
        echo "Error processing $file"
        exit 1  # Stop on error
    fi
done
```

**After (v5.7.0) - Robust**:
```bash
#!/bin/bash
# Process all files in one go
verible-verilog-syntax \
    --export_indexed_json \
    --continue_on_error \
    *.sv > all_files.json

if [ $? -ne 0 ]; then
    echo "Some files had errors (but all were processed)"
fi

# Parse results with Python/jq
jq '.cst | to_entries[] | select(.value.status == "failed") | .key' all_files.json
```

---

### Pattern 2: CI/CD Integration

**Before (v5.6.0)**:
```yaml
# .github/workflows/verible.yml
- name: Check syntax
  run: |
    for file in $(find . -name "*.sv"); do
      verible-verilog-syntax --export_json "$file" || exit 1
    done
```

**After (v5.7.0) - Better**:
```yaml
# .github/workflows/verible.yml
- name: Check syntax
  run: |
    verible-verilog-syntax \
      --export_indexed_json \
      --continue_on_error \
      $(find . -name "*.sv") > syntax-report.json
    
    # Check if any files failed
    if [ $? -ne 0 ]; then
      echo "::error::Some files failed syntax check"
      # Extract failed files
      jq -r '.cst | to_entries[] | 
             select(.value.status == "failed") | 
             .key' syntax-report.json
      exit 1
    fi
```

---

### Pattern 3: VeriPG Integration

**Before (v4.8.10-v5.6.0)**:
```python
# VeriPG knowledge graph builder
data = json.load(f)

for filename, file_data in data.items():
    tree = file_data["tree"]
    # Problem: Unclear file path handling in multi-file batch
    build_knowledge_graph(tree)
```

**After (v5.7.0) - Correct**:
```python
# VeriPG knowledge graph builder
data = json.load(f)

# Get file index
file_index = data.get("file_index", {})
export_format = data.get("export_format", "standard")

if export_format == "indexed":
    # v5.7.0 indexed mode
    cst_data = data["cst"]
else:
    # v5.6.0 standard mode
    cst_data = {k: v for k, v in data.items() 
                if k not in METADATA_FIELDS}

for filename, file_data in cst_data.items():
    if file_data.get("status") != "success":
        continue  # Skip failed files
    
    tree = file_data["tree"]
    
    # Resolve file references
    def resolve_file(node):
        if "file" in node:
            file_ref = node["file"]
            if file_ref.startswith("<indexed>:"):
                index_id = file_ref.split(":")[1]
                node["file"] = file_index[index_id]
        return node
    
    # Build knowledge graph with resolved paths
    build_knowledge_graph(resolve_file(tree))
```

---

## 5. Testing Your Migration

### Test Suite

Create a test to ensure your migration works:

```python
# test_verible_v570_migration.py
import json
import subprocess
import unittest

class TestVeribleV570Migration(unittest.TestCase):
    
    def test_standard_json_backward_compat(self):
        """Test v5.6.0 --export_json still works"""
        result = subprocess.run([
            "verible-verilog-syntax",
            "--export_json",
            "test.sv"
        ], capture_output=True)
        
        data = json.loads(result.stdout)
        
        # v5.7.0 adds metadata
        self.assertIn("verible_version", data)
        self.assertIn("cst_schema_version", data)
        
        # But file data still accessible
        self.assertIn("test.sv", data)
        self.assertIn("tree", data["test.sv"])
    
    def test_indexed_json_new_feature(self):
        """Test --export_indexed_json works"""
        result = subprocess.run([
            "verible-verilog-syntax",
            "--export_indexed_json",
            "test1.sv",
            "test2.sv"
        ], capture_output=True)
        
        data = json.loads(result.stdout)
        
        # New indexed format
        self.assertIn("file_index", data)
        self.assertIn("cst", data)
        self.assertEqual(data["export_format"], "indexed")
        
        # File index maps correctly
        file_index = data["file_index"]
        self.assertEqual(len(file_index), 2)
        self.assertIn("0", file_index)
        self.assertIn("1", file_index)
    
    def test_continue_on_error(self):
        """Test --continue_on_error processes all files"""
        result = subprocess.run([
            "verible-verilog-syntax",
            "--continue_on_error",
            "--export_json",
            "valid.sv",
            "invalid.sv"
        ], capture_output=True)
        
        # Exit code 1 (error occurred)
        self.assertEqual(result.returncode, 1)
        
        data = json.loads(result.stdout)
        
        # Both files processed
        self.assertIn("valid.sv", data)
        self.assertIn("invalid.sv", data)
        
        # Status tracking
        self.assertEqual(data["valid.sv"]["status"], "success")
        self.assertEqual(data["invalid.sv"]["status"], "failed")

if __name__ == "__main__":
    unittest.main()
```

### Run Tests

```bash
python test_verible_v570_migration.py -v
```

---

## 6. Rollback Plan (If Needed)

If you encounter issues with v5.7.0:

### Option 1: Use v5.6.0 Binary

```bash
# Keep v5.6.0 binary as fallback
cp verible-verilog-syntax verible-verilog-syntax-v5.6.0

# Upgrade to v5.7.0
# (download/build v5.7.0)

# If issues, rollback
cp verible-verilog-syntax-v5.6.0 verible-verilog-syntax
```

### Option 2: Git Checkout

```bash
# Checkout v5.6.0
git checkout v5.6.0
bazel build -c opt //verible/verilog/tools/syntax:verible-verilog-syntax
```

**Note**: v5.7.0 is thoroughly tested and backward compatible. Rollback should not be necessary.

---

## 7. Troubleshooting

### Issue: "verible_version field unexpected"

**Symptom**: Your JSON parser fails on new metadata fields

**Solution**: Update parser to skip unknown top-level fields
```python
# Robust approach
METADATA_FIELDS = {"verible_version", "cst_schema_version", 
                   "export_format", "timestamp"}
file_data = {k: v for k, v in data.items() if k not in METADATA_FIELDS}
```

---

### Issue: "Missing 'tree' field"

**Symptom**: `KeyError: 'tree'` when accessing file data

**Cause**: File failed to parse, no tree generated

**Solution**: Check status field first
```python
file_data = data["myfile.sv"]
status = file_data.get("status", "unknown")

if status == "success":
    tree = file_data["tree"]
else:
    # Handle error case
    errors = file_data.get("errors", [])
    print(f"Parse failed: {errors}")
```

---

### Issue: "Can't find file for <indexed>:0"

**Symptom**: CST references `<indexed>:0` but unclear how to resolve

**Solution**: Use file_index mapping
```python
file_index = data["file_index"]
indexed_id = "0"  # From "<indexed>:0"
actual_path = file_index[indexed_id]
```

---

## 8. Best Practices

### ‚úÖ Do:
- Keep v5.6.0 binary as backup during initial migration
- Update JSON parsers to handle version metadata
- Use `--continue_on_error` for batch processing
- Use `--export_indexed_json` for multi-file workflows
- Check `status` field before accessing `tree`
- Validate `cst_schema_version` for forward compatibility

### ‚ùå Don't:
- Assume all files have `tree` field (check `status` first)
- Mix `--export_json` and `--export_indexed_json` flags
- Ignore version metadata (use it for debugging)
- Skip testing your migration before production deployment

---

## 9. Support & Resources

**Documentation**:
- `V5.7.0_RELEASE_NOTES.md` - Full feature list
- `docs/EXPORT_FORMATS_v5.7.0.md` - Detailed export format guide (700+ lines)
- `V5.7.0_IMPLEMENTATION_REPORT.md` - Technical details

**Getting Help**:
- GitHub Issues: Report bugs or ask questions
- Check existing issues for similar problems

**Migration Checklist**:
- [ ] Build/download v5.7.0 binary
- [ ] Verify version with `--version`
- [ ] Test with sample files
- [ ] Update JSON parsers (if applicable)
- [ ] Run your test suite
- [ ] Update documentation
- [ ] Deploy to production

---

## 10. Summary

**Time Investment**: 10-30 minutes  
**Difficulty**: Easy  
**Breaking Changes**: None  
**Backward Compatibility**: 100%

**Key Takeaway**: v5.7.0 is a drop-in replacement for v5.6.0. You can upgrade immediately and adopt new features incrementally.

---

**Migration Complete!** üéâ

Your workflows are now running on v5.7.0 with access to enhanced batch processing and error handling.

