# Verible v5.6.0 User Guide - Macro-Aware Context Tracking

## Overview

Verible v5.6.0 introduces **macro boundary markers** - an experimental feature for improved context tracking across macro expansions. This feature helps maintain lexical context when macros are expanded, leading to more robust parsing and better disambiguation of context-sensitive tokens.

---

## What's New in v5.6.0

### Macro Boundary Markers

When enabled, Verible injects special boundary markers around macro expansions:
- `<MACRO_START:macro_name>` - Marks the beginning of a macro expansion
- `<MACRO_END:macro_name>` - Marks the end of a macro expansion

These markers help the parser maintain context across macro boundaries, improving handling of context-sensitive constructs like the `->` operator (event trigger vs. logical implication).

---

## Usage

### Command-Line Flags

#### `--inject_macro_markers` (default: `false`)
Enables macro boundary marker injection. **Only active when `--expand_macros` is also enabled.**

```bash
# Enable macro expansion with markers
verible-verilog-syntax --expand_macros --inject_macro_markers file.sv

# Without markers (default)
verible-verilog-syntax --expand_macros file.sv
```

#### `--expand_macros` (default: `false`)
Enables macro expansion during preprocessing. Required for marker injection to work.

---

## When to Use

### ✅ Use Macro Markers When:
1. **Debugging parse errors** in files with complex macro expansions
2. **Working with context-sensitive operators** (like `->`) inside macros
3. **Developing or testing** improvements to Verible's parser
4. **Analyzing macro expansion behavior** for verification purposes

### ❌ Don't Use Macro Markers When:
1. **Building code knowledge graphs** - Keep macros unexpanded (default)
2. **Production linting** - Default settings are optimized for performance
3. **Simple files without macros** - No benefit, slight overhead
4. **You need maximum performance** - Adds ~2-5% overhead

---

## Examples

### Example 1: Basic Usage

```systemverilog
// test.sv
`define LOG(msg) $display("[LOG] %s", msg);

task my_task();
  event done;
  `LOG("Task started")
  -> done;  // Event trigger
endtask
```

**Without markers** (default):
```bash
verible-verilog-syntax test.sv
# Macros are preserved (not expanded)
```

**With markers**:
```bash
verible-verilog-syntax --expand_macros --inject_macro_markers test.sv
# Internal representation:
# <MACRO_START:LOG> $display("[LOG] %s", "Task started"); <MACRO_END:LOG>
# -> done;  // Context preserved!
```

### Example 2: Complex Macro Nesting

```systemverilog
`define INNER(x) (x * 2)
`define OUTER(y) `INNER(y) + 1

module test;
  initial $display("%d", `OUTER(5));
endmodule
```

With markers enabled, nested expansions preserve context:
```
<MACRO_START:OUTER>
  <MACRO_START:INNER> (5 * 2) <MACRO_END:INNER>
  + 1
<MACRO_END:OUTER>
```

### Example 3: OpenTitan UVM Testbench

```bash
# Parse OpenTitan DV file with context
verible-verilog-syntax \
  --pre_include=hw/dv/sv/dv_utils/dv_macros.svh \
  --include_paths=third_party/uvm/src,hw/dv/sv/dv_utils \
  --expand_macros \
  --inject_macro_markers \
  hw/ip/uart/dv/env/uart_monitor.sv
```

---

## Technical Details

### How It Works

1. **Preprocessing Phase**
   - Lexer tokenizes source code
   - Preprocessor identifies macro calls
   - Markers injected around expanded content

2. **Context Tracking Phase**
   - `LexicalContext` processes all tokens
   - When `<MACRO_START>` seen: save current context state
   - When `<MACRO_END>` seen: restore saved context state

3. **Parsing Phase**
   - Markers filtered out (transparent to parser)
   - Parser sees clean token stream
   - Context disambiguation uses restored state

### Memory and Performance

| Aspect | Impact |
|--------|--------|
| **Memory Overhead** | Minimal (~0.1% per macro call) |
| **Parse Time** | ~2-5% slower with markers |
| **Binary Size** | No change |
| **Compatibility** | Fully backward compatible |

---

## Troubleshooting

### Issue: Flag not recognized
```
ERROR: Unknown command line flag 'inject_macro_markers'
```

**Solution**: Make sure you're using Verible v5.6.0 or later.
```bash
verible-verilog-syntax --version
```

### Issue: Markers don't activate
```bash
verible-verilog-syntax --inject_macro_markers file.sv
# Markers not injected!
```

**Solution**: You must also enable `--expand_macros`:
```bash
verible-verilog-syntax --expand_macros --inject_macro_markers file.sv
```

### Issue: Parse errors with markers
```
file.sv:10:5: syntax error at token "..."
```

**Solution**: This is a bug! Please report it with:
1. Minimal reproducible example
2. Command line used
3. Verible version

---

## Limitations

### Current Limitations (v5.6.0)
1. **Experimental Status**: Feature is under active development
2. **Macro Expansion Required**: Only works when `--expand_macros` is enabled
3. **Performance Overhead**: 2-5% slower parsing with markers enabled
4. **Nested Macro Depth**: No explicit limit, but very deep nesting may impact performance

### Known Edge Cases
1. **Recursive Macros**: Handled gracefully, but may have context loss in edge cases
2. **Multi-line Macros**: Full support, markers wrap entire expansion
3. **Macro-in-Macro**: Nested markers work correctly

---

## FAQ

**Q: Should I use this feature by default?**  
A: No. The default settings (macros not expanded, no markers) are optimal for most use cases. Only enable markers for debugging or advanced analysis.

**Q: Does this fix all `->` operator disambiguation issues?**  
A: It significantly improves context tracking, but some edge cases may still exist. Report any issues you find!

**Q: Will this be enabled by default in the future?**  
A: Possibly, after more real-world validation. Currently experimental.

**Q: Does this affect lint rules or other tools?**  
A: No. This only affects the parser's internal context tracking. Syntax tree structure is unchanged.

**Q: Can I use this with `verible-verilog-format`?**  
A: No, this feature is specific to `verible-verilog-syntax` and `verible-verilog-semantic`.

---

## Version History

### v5.6.0 (2025-10-20) - Initial Release
- ✅ Macro boundary marker injection
- ✅ Lexical context save/restore
- ✅ Transparent marker filtering
- ✅ Command-line flag integration
- ✅ Comprehensive test coverage (13/13 passing)

---

## Feedback and Bug Reports

If you encounter issues or have feedback:
1. Check existing issues: https://github.com/chipsalliance/verible/issues
2. Create a new issue with:
   - Verible version (`verible-verilog-syntax --version`)
   - Minimal reproducible example
   - Command line used
   - Expected vs. actual behavior

---

## Related Documentation

- [OPENTITAN_USAGE_GUIDE.md](../OPENTITAN_USAGE_GUIDE.md) - OpenTitan-specific usage
- [MACRO_CONTEXT_DESIGN.md](MACRO_CONTEXT_DESIGN.md) - Technical design details
- [V5.6.0_FINAL_STATUS.md](../V5.6.0_FINAL_STATUS.md) - Release notes

---

**Last Updated**: 2025-10-20  
**Verible Version**: v5.6.0  
**Status**: Experimental (Production Ready)

