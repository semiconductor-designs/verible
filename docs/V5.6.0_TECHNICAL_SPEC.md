# Verible v5.6.0 Technical Specification

**Version**: v5.6.0  
**Status**: Design Phase  
**Date**: October 19, 2025  
**Authors**: Development Team

---

## 1. Overview

### 1.1 Objective

Implement macro-aware context tracking to achieve 100% correctness in `->` operator disambiguation by preserving parser context through macro expansion.

### 1.2 Current Problem

**v5.5.0 uses a heuristic approach** (lines 698-721 in `verilog-lexical-context.cc`):
- Checks previous token to infer context
- Works for 100% of tested cases
- Not theoretically perfect
- May have undiscovered edge cases

**Root cause**: After macro expansion, the parser loses track of statement boundaries because:
1. Macro expands to multiple tokens
2. Parser state (`ExpectingBodyItemStart()`) doesn't track through expansion
3. Previous token after expansion doesn't indicate statement boundary

### 1.3 Proposed Solution

**Macro Boundary Markers (Option 1)**:
- Inject special tokens at macro expansion boundaries
- Preserve context by saving/restoring parser state
- Handle nested macros correctly
- Theoretically perfect, no heuristics needed

---

## 2. API Design

### 2.1 Token Definitions

**New tokens in `verible/verilog/parser/verilog-token-enum.h`**:

```cpp
// After existing token definitions (~line 150)
TK_MACRO_BOUNDARY_START = 450,  // <MACRO_START:name>
TK_MACRO_BOUNDARY_END = 451,    // <MACRO_END:name>
```

**Lexer rules in `verible/verilog/parser/verilog.lex`**:

```cpp
// After line 837 (after existing token rules)
"<MACRO_START:"[a-zA-Z_][a-zA-Z0-9_]*">"  { 
  return TK_MACRO_BOUNDARY_START; 
}
"<MACRO_END:"[a-zA-Z_][a-zA-Z0-9_]*">"    { 
  return TK_MACRO_BOUNDARY_END; 
}
```

**Token format**:
- `<MACRO_START:macro_name>` - Injected before macro expansion
- `<MACRO_END:macro_name>` - Injected after macro expansion
- Includes macro name for debugging/logging

### 2.2 Context State Structure

**In `verible/verilog/parser/verilog-lexical-context.h`** (add after line 200):

```cpp
// Context state for macro boundary preservation
struct ContextState {
  // Statement context
  bool expecting_statement;
  bool in_statement_context;
  
  // Procedural block context
  bool in_task_body;
  bool in_function_body;
  bool in_initial_always_final_construct;
  
  // Nesting depth
  int balance_depth;
  int brace_depth;
  
  // Active trackers
  bool randomize_active;
  bool constraint_declaration_active;
  
  // Previous token (for fallback)
  const TokenInfo* previous_token;
  
  // Constructor
  ContextState() 
    : expecting_statement(false),
      in_statement_context(false),
      in_task_body(false),
      in_function_body(false),
      in_initial_always_final_construct(false),
      balance_depth(0),
      brace_depth(0),
      randomize_active(false),
      constraint_declaration_active(false),
      previous_token(nullptr) {}
};
```

### 2.3 LexicalContext Extensions

**In `verible/verilog/parser/verilog-lexical-context.h`** (add to private section):

```cpp
private:
  // Macro context tracking
  int macro_depth_ = 0;
  std::stack<ContextState> saved_context_stack_;
  
  // Context state management
  ContextState SaveCurrentContext() const;
  void RestoreContext(const ContextState& state);
  
  // Enhanced for debugging
  void LogContextState(const std::string& event) const;
```

---

## 3. Implementation Details

### 3.1 Macro Boundary Marker Injection

**Location**: `verible/verilog/preprocessor/verilog-preprocess.cc`  
**Function**: `VerilogPreprocess::HandleMacroIdentifier()`  
**Line**: ~400-600 (varies by version)

**Implementation**:

```cpp
absl::Status VerilogPreprocess::HandleMacroIdentifier(
    const TokenInfo& macro_id_token) {
  const absl::string_view macro_name = macro_id_token.text();
  
  // STEP 1: Inject start marker
  std::ostringstream marker_start;
  marker_start << "<MACRO_START:" << macro_name << ">";
  output_stream_ << marker_start.str();
  
  // STEP 2: Existing macro expansion logic
  // ... (keep all existing code) ...
  
  // Find macro definition
  const MacroDefinition* macro = FindOrNull(macro_definitions_, macro_name);
  if (!macro) {
    return absl::NotFoundError("Macro not defined: " + std::string(macro_name));
  }
  
  // Expand macro (existing logic)
  RETURN_IF_ERROR(ExpandMacro(*macro, args, output_stream_));
  
  // STEP 3: Inject end marker
  std::ostringstream marker_end;
  marker_end << "<MACRO_END:" << macro_name << ">";
  output_stream_ << marker_end.str();
  
  return absl::OkStatus();
}
```

**Key points**:
- Markers injected into token stream, not source text
- Macro name included for debugging
- Nested expansions handled automatically (each gets own markers)

### 3.2 Context Preservation Logic

**Location**: `verible/verilog/parser/verilog-lexical-context.cc`  
**Function**: `LexicalContext::InterpretToken()`  
**Line**: Add new cases before line 670

**Implementation**:

```cpp
case TK_MACRO_BOUNDARY_START: {
  VLOG(2) << "MACRO_BOUNDARY_START: depth " << macro_depth_ 
          << " -> " << (macro_depth_ + 1);
  
  // Save current context
  ContextState state = SaveCurrentContext();
  saved_context_stack_.push(state);
  macro_depth_++;
  
  LogContextState("MACRO_START");
  
  // Pass through marker (don't modify token stream)
  return token_enum;
}

case TK_MACRO_BOUNDARY_END: {
  VLOG(2) << "MACRO_BOUNDARY_END: depth " << macro_depth_ 
          << " -> " << (macro_depth_ - 1);
  
  // Restore previous context
  if (!saved_context_stack_.empty()) {
    ContextState state = saved_context_stack_.top();
    saved_context_stack_.pop();
    RestoreContext(state);
    
    LogContextState("MACRO_END");
  } else {
    LOG(WARNING) << "Context stack empty at MACRO_END (unbalanced markers)";
  }
  
  macro_depth_--;
  
  // Pass through marker
  return token_enum;
}
```

**SaveCurrentContext() implementation**:

```cpp
ContextState LexicalContext::SaveCurrentContext() const {
  ContextState state;
  
  state.expecting_statement = ExpectingStatement();
  state.in_statement_context = InStatementContext();
  state.in_task_body = in_task_body_;
  state.in_function_body = in_function_body_;
  state.in_initial_always_final_construct = in_initial_always_final_construct_;
  state.balance_depth = balance_stack_.size();
  state.brace_depth = brace_stack_.size();
  state.randomize_active = randomize_call_tracker_.IsActive();
  state.constraint_declaration_active = constraint_declaration_tracker_.IsActive();
  state.previous_token = previous_token_;
  
  return state;
}
```

**RestoreContext() implementation**:

```cpp
void LexicalContext::RestoreContext(const ContextState& state) {
  // Restore boolean flags
  in_task_body_ = state.in_task_body;
  in_function_body_ = state.in_function_body;
  in_initial_always_final_construct_ = state.in_initial_always_final_construct;
  
  // Note: Stack depths are informational only, don't restore stacks
  // The stacks continue to track naturally through the expanded code
  
  // Restore previous token for heuristic fallback
  previous_token_ = state.previous_token;
  
  VLOG(2) << "Context restored: task=" << in_task_body_ 
          << " function=" << in_function_body_
          << " initial/always=" << in_initial_always_final_construct_;
}
```

### 3.3 Updated Arrow Disambiguation

**Location**: `verible/verilog/parser/verilog-lexical-context.cc`  
**Function**: `LexicalContext::InterpretToken()` case `_TK_RARROW`  
**Line**: 670-729

**Modified logic**:

```cpp
case _TK_RARROW: {
  VLOG(1) << "InterpretToken: _TK_RARROW";
  VLOG(1) << "  macro_depth=" << macro_depth_;
  
  // ... existing constraint/randomize checks ...
  
  // NEW: If we're inside a macro expansion, use saved context
  if (macro_depth_ > 0 && !saved_context_stack_.empty()) {
    const ContextState& saved = saved_context_stack_.top();
    
    // Use saved context to determine if we expect a statement
    if (saved.in_task_body || saved.in_function_body || 
        saved.in_initial_always_final_construct) {
      // We were in procedural context before macro
      // Check if we were expecting a statement
      if (saved.expecting_statement) {
        VLOG(1) << "  -> TK_TRIGGER (saved context: expecting statement)";
        return TK_TRIGGER;
      }
    }
  }
  
  // Existing logic for non-macro cases
  const bool expecting_stmt = ExpectingStatement();
  if (expecting_stmt) {
    VLOG(1) << "  -> TK_TRIGGER (current context: expecting statement)";
    return TK_TRIGGER;
  }
  
  // Existing heuristic fallback (lines 707-721)
  if ((in_task_body_ || in_function_body_) && previous_token_ != nullptr) {
    // ... existing heuristic code ...
  }
  
  // Default: logical implication
  VLOG(1) << "  -> TK_LOGICAL_IMPLIES (expression context)";
  return TK_LOGICAL_IMPLIES;
}
```

---

## 4. Nested Macro Handling

### 4.1 Scenario

```systemverilog
`define OUTER(x) `INNER(x) + 1
`define INNER(y) y * 2

task test();
  `OUTER(5)  // Expands to: `INNER(5) + 1
             // Then to: 5 * 2 + 1
  -> event;
endtask
```

### 4.2 Token Stream

```
task test ( ) ;
<MACRO_START:OUTER>
<MACRO_START:INNER>
5 * 2
<MACRO_END:INNER>
+ 1
<MACRO_END:OUTER>
-> event ;
endtask
```

### 4.3 Context Stack

```
Depth 0: Initial state (in_task_body=true)
Depth 1: OUTER expansion starts, save state → stack[0]
Depth 2: INNER expansion starts, save state → stack[1]
Depth 2→1: INNER ends, restore stack[1]
Depth 1→0: OUTER ends, restore stack[0]
Depth 0: -> disambiguation uses original context
```

---

## 5. Performance Impact Analysis

### 5.1 Memory Overhead

**Per macro expansion**:
- ContextState: ~80 bytes (10 bools + 4 ints + 1 pointer)
- Stack entry: ~100 bytes including overhead
- Typical nesting: 2-3 levels = 200-300 bytes

**Worst case**:
- Deep nesting (10 levels): ~1 KB
- File with 100 macros: ~8-10 KB total
- Acceptable for modern systems

### 5.2 Time Overhead

**Marker injection**: 
- Per macro: ~10-20 CPU cycles (string concat)
- Negligible compared to macro expansion itself

**Context save/restore**:
- Per boundary: ~50-100 CPU cycles (copy struct + stack ops)
- Still negligible vs parsing

**Expected total overhead**: <2% for typical files, <5% for macro-heavy files

### 5.3 Optimization Opportunities

If performance becomes an issue:
1. **Lazy context saving**: Only save when needed (in procedural blocks)
2. **Context pooling**: Reuse ContextState objects
3. **Stack size limit**: Cap at 20 levels, error on deeper nesting
4. **Marker filtering**: Remove markers after parsing if not needed

---

## 6. Test Strategy

### 6.1 Unit Tests (20+ tests)

**Basic functionality** (5 tests):
1. `SimpleMacroBoundaryMarkers` - Markers injected and recognized
2. `ContextSaveRestore` - State saved and restored correctly
3. `MacroDepthTracking` - Depth increments/decrements properly
4. `EmptyContextStack` - Handle underflow gracefully
5. `StackOverflow` - Handle deep nesting (20+ levels)

**Arrow disambiguation** (5 tests):
6. `EventTriggerAfterMacroWithMarkers` - Original use case
7. `LogicalImplicationInMacro` - Expression context preserved
8. `NestedMacroEventTrigger` - Works with 2+ nesting levels
9. `MacroInTaskBody` - Context across different procedural blocks
10. `MacroInModuleBody` - Non-procedural context preserved

**Nested macros** (5 tests):
11. `TwoLevelNesting` - Basic nested expansion
12. `ThreeLevelNesting` - Deeper nesting
13. `MacroExpandingToMacro` - Indirect expansion
14. `RecursiveMacroDetection` - Don't infinite loop
15. `UnbalancedMarkers` - Handle mismatched start/end

**Edge cases** (5 tests):
16. `MacroWithNoExpansion` - Empty macro body
17. `MacroWithWhitespace` - Spaces/newlines in expansion
18. `MacroWithComments` - Comments in macro body
19. `MultipleArrowsInMacro` - Multiple `->` in one expansion
20. `MixedHeuristicAndMarkers` - Graceful degradation

**Performance** (2 tests):
21. `PerformanceBenchmark` - Compare vs v5.5.0
22. `DeepNestingPerformance` - 10+ levels still acceptable

### 6.2 Integration Tests

**OpenTitan corpus**: 3911 files
- Target: 100% success (maintain v5.5.0 rate)
- Focus: UVM patterns with heavy macro usage

**Ibex corpus**: 637 files
- Target: 97%+ success
- Focus: RTL with moderate macro usage

**PULPino corpus**: 44 files
- Target: 97%+ success
- Focus: Mixed RTL/verification

**Synthetic edge cases**: 100+ manually crafted
- Target: 100% success
- Cover all combinations in test matrix

---

## 7. Debugging and Logging

### 7.1 VLOG Levels

**VLOG(1)**: High-level decisions
```cpp
VLOG(1) << "InterpretToken: _TK_RARROW -> " << result;
```

**VLOG(2)**: Macro context operations
```cpp
VLOG(2) << "MACRO_START: saving context at depth " << macro_depth_;
VLOG(2) << "Context state: task=" << in_task_body_ << " expecting=" << ExpectingStatement();
```

**VLOG(3)**: Detailed state dumps
```cpp
VLOG(3) << "Full context state: " << DumpContextState();
```

### 7.2 Debug Flags

Add to `verilog-syntax.cc`:
```cpp
ABSL_FLAG(bool, debug_macro_markers, false,
          "Enable debug logging for macro boundary markers");

ABSL_FLAG(bool, show_macro_markers, false,
          "Print macro markers in token stream (for debugging)");
```

---

## 8. Backward Compatibility

### 8.1 Token Stream Changes

**Markers are internal**: Not visible in:
- Syntax tree (CST)
- Pretty-printed output
- Error messages
- User-facing APIs

**Markers filtered**: Remove from token stream after parsing if needed

### 8.2 API Compatibility

**No breaking changes**:
- All existing APIs unchanged
- New APIs optional (mode selection flag)
- Default behavior: use macro-aware if available
- Fallback: heuristic still works if markers fail

### 8.3 Migration Path

**v5.5.0 → v5.6.0**:
- Drop-in replacement
- No config changes needed
- Optional: enable `--arrow_disambiguation_mode` flag
- Optional: enable `--debug_macro_markers` for verification

---

## 9. Success Criteria

### 9.1 Functional

- ✅ All existing tests pass (regression-free)
- ✅ 20+ new tests pass
- ✅ OpenTitan: 100% success (3911/3911)
- ✅ Ibex: 97%+ success (617+/637)
- ✅ PULPino: 97%+ success (43+/44)
- ✅ Synthetic: 100% success (100+/100)

### 9.2 Non-Functional

- ✅ Performance: <5% degradation
- ✅ Memory: <10% increase
- ✅ No memory leaks (AddressSanitizer clean)
- ✅ Thread-safe (if applicable)
- ✅ Code review approved

### 9.3 Documentation

- ✅ Technical spec complete (this document)
- ✅ User guides updated
- ✅ Release notes written
- ✅ Inline comments comprehensive

---

## 10. Open Questions

### 10.1 Resolved

None yet (design phase)

### 10.2 To Investigate

1. **Filter markers from CST?** 
   - Likely yes, users shouldn't see them
   - Need to verify with tree printing tests

2. **Marker format final?**
   - `<MACRO_START:name>` vs `MACRO_START(name)`
   - Current format easier to lex

3. **Handle macro concatenation (`##`)?**
   - May need special handling
   - Test during PoC

4. **Interaction with conditional compilation?**
   - `ifdef/`ifndef/`else/`endif
   - Need integration tests

---

## 11. Timeline

**Week 1**: This specification document ✅  
**Week 2**: Update MACRO_CONTEXT_DESIGN.md, create feature branch  
**Week 3-4**: Proof-of-concept implementation  
**Week 5-12**: Full implementation (see main plan)

---

## 12. References

- **Main Plan**: `V5.6.0_MEDIUM_TERM_PLAN.md`
- **Design Doc**: `docs/MACRO_CONTEXT_DESIGN.md`
- **Current Code**: `verible/verilog/parser/verilog-lexical-context.cc` (lines 698-721)
- **Preprocessor**: `verible/verilog/preprocessor/verilog-preprocess.cc`

---

**Document Version**: 1.0  
**Status**: Complete - Ready for Review  
**Next Step**: Update MACRO_CONTEXT_DESIGN.md with detailed examples

