# Feature 3: Package Context Mode - Implementation Plan

**Date**: 2025-01-15  
**Replaces**: Command-Line Defines (-D flag)  
**Why**: Addresses root cause of OpenTitan failures  
**Effort**: 3-4 days  
**Impact**: üéØ 100% OpenTitan success without manual includes

---

## üéØ The Problem

OpenTitan UVM testbench files are designed for **package compilation**:

```systemverilog
// dv_base_test_pkg.sv (package file)
package dv_base_test_pkg;
  `include "uvm_macros.svh"
  `include "dv_macros.svh"
  
  import uvm_pkg::*;
  
  `define CUSTOM_MACRO 42
  
  class dv_base_test extends uvm_test;
    // ...
  endclass
endpackage

// my_test.sv (testbench file - designed for package context!)
class my_custom_test extends dv_base_test;
  // This file ASSUMES it's compiled within dv_base_test_pkg context
  // It expects `CUSTOM_MACRO to be available
  // It expects dv_base_test to be in scope
  int value = `CUSTOM_MACRO;  // ‚ùå FAILS when parsed in isolation
endclass
```

**Current Workaround**: Users must:
1. Add `--pre_include` for every macro file (tedious)
2. Or add explicit `include directives (modifies source)
3. Or parse the entire package (loses granular file analysis)

**Better Solution**: `--package-context` flag!

---

## üöÄ The Solution

```bash
# Parse testbench file with package context
verible-verilog-syntax \
  --package-context=dv_base_test_pkg.sv \
  my_test.sv

# What happens:
# 1. Parse dv_base_test_pkg.sv
# 2. Extract all macro definitions
# 3. Extract all type definitions (classes, typedefs)
# 4. Make them available when parsing my_test.sv
# 5. ‚úÖ SUCCESS - file parses as if in package context!
```

**Multiple packages**:
```bash
verible-verilog-syntax \
  --package-context=uvm_pkg.sv \
  --package-context=dv_base_test_pkg.sv \
  my_test.sv
```

**Auto-detect from filename**:
```bash
# If my_test.sv is in package_tests/ directory,
# automatically look for package_tests_pkg.sv
verible-verilog-syntax \
  --auto-detect-package \
  my_test.sv
```

---

## üìê Architecture

### High-Level Design

```
PackageContextResolver
    ‚Üì
1. Parse package file(s)
2. Extract context:
   - Macro definitions (from `define and `include)
   - Type definitions (class, typedef, enum)
   - Import statements (track dependencies)
3. Create PackageContext object
    ‚Üì
4. Pass to VerilogAnalyzer
5. Seed preprocessor + symbol table
    ‚Üì
6. Parse target file with enriched context
7. ‚úÖ File parses successfully!
```

### Data Flow

```
main() in verilog-syntax.cc
    ‚Üì
Check FLAGS_package_context
    ‚Üì
Create PackageContextResolver
    ‚Üì
For each package file:
  - Load and parse package
  - Extract macros (reuse PreloadIncludes!)
  - Extract type definitions (new!)
  - Accumulate in PackageContext
    ‚Üì
Pass PackageContext to analyzer
    ‚Üì
VerilogAnalyzer::SetPackageContext()
  - Seeds preprocessor with macros
  - Seeds symbol table with types
    ‚Üì
Parse target file
    ‚Üì
‚úÖ SUCCESS - context available!
```

---

## üõ†Ô∏è Implementation (TDD Approach)

### Phase 1: RED - Tests First (Day 1, 4 hours)

**File**: `verible/verilog/analysis/package-context-resolver_test.cc`

#### Unit Tests (8 tests)

1. **TEST(PackageContextResolverTest, ParseSimplePackage)**
   - Input: Package with single macro
   - Verify: Macro extracted

2. **TEST(PackageContextResolverTest, ParsePackageWithIncludes)**
   - Input: Package with `include "macros.svh"
   - Verify: Included macros extracted

3. **TEST(PackageContextResolverTest, ParseMultiplePackages)**
   - Input: Two packages with different macros
   - Verify: Both sets of macros available

4. **TEST(PackageContextResolverTest, ExtractClassDefinitions)**
   - Input: Package with class definitions
   - Verify: Class names and types extracted

5. **TEST(PackageContextResolverTest, ExtractTypedefDefinitions)**
   - Input: Package with typedefs
   - Verify: Type aliases extracted

6. **TEST(PackageContextResolverTest, HandleImportStatements)**
   - Input: Package importing uvm_pkg::*
   - Verify: Import recorded (for future enhancement)

7. **TEST(PackageContextResolverTest, PackageFileNotFound)**
   - Input: Non-existent package file
   - Verify: Error with helpful message

8. **TEST(PackageContextResolverTest, CircularPackageDependency)**
   - Input: Package A imports Package B imports Package A
   - Verify: Detection and error

#### Integration Tests (4 tests)

**File**: `verible/verilog/tools/syntax/verilog-syntax-package_test.cc`

1. **TEST(PackageContextIntegration, SimpleTestWithPackage)**
   - Package: Define `TEST_MACRO
   - Test file: Use `TEST_MACRO
   - Verify: Parses successfully

2. **TEST(PackageContextIntegration, UVMStylePackage)**
   - Package: Include uvm_macros.svh, define UVM test
   - Test file: Extend UVM test, use UVM macros
   - Verify: Parses successfully

3. **TEST(PackageContextIntegration, MultiplePackageChain)**
   - Package A: Base macros
   - Package B: Imports A, adds more macros
   - Test file: Uses macros from both
   - Verify: Parses with both packages

4. **TEST(PackageContextIntegration, AutoDetectPackage)**
   - Directory: test_pkg/
   - Package: test_pkg/test_pkg.sv
   - Test file: test_pkg/my_test.sv
   - Verify: Auto-detects and uses package

**Target**: 0/12 tests passing (RED phase ‚úÖ)

---

### Phase 2: GREEN - Implementation (Days 2-3, 12 hours)

#### Step 1: Create PackageContext Data Structure

**File**: `verible/verilog/analysis/package-context.h`

```cpp
#ifndef VERIBLE_VERILOG_ANALYSIS_PACKAGE_CONTEXT_H_
#define VERIBLE_VERILOG_ANALYSIS_PACKAGE_CONTEXT_H_

#include <map>
#include <string>
#include <string_view>
#include <vector>

#include "verible/verilog/preprocessor/verilog-preprocess.h"

namespace verilog {

// Context from a SystemVerilog package for parsing files in that context
struct PackageContext {
  // Package name
  std::string package_name;
  
  // Macro definitions from package (including from includes)
  VerilogPreprocessData::MacroDefinitionRegistry macro_definitions;
  
  // Type definitions (class names, typedefs, enums)
  // For v5.4.0: Just track names for now (full type info in v5.5.0)
  std::vector<std::string> type_names;
  
  // Import statements (for future use)
  std::vector<std::string> imports;
  
  // Source file path
  std::string source_file;
};

// Combines multiple package contexts
struct CombinedPackageContext {
  std::vector<PackageContext> packages;
  
  // Flattened view of all macros
  VerilogPreprocessData::MacroDefinitionRegistry all_macros;
  
  // Flattened view of all types
  std::vector<std::string> all_types;
};

}  // namespace verilog

#endif
```

#### Step 2: Implement PackageContextResolver

**File**: `verible/verilog/analysis/package-context-resolver.h`

```cpp
#ifndef VERIBLE_VERILOG_ANALYSIS_PACKAGE_CONTEXT_RESOLVER_H_
#define VERIBLE_VERILOG_ANALYSIS_PACKAGE_CONTEXT_RESOLVER_H_

#include <memory>
#include <string>
#include <vector>

#include "absl/status/statusor.h"
#include "verible/verilog/analysis/include-file-resolver.h"
#include "verible/verilog/analysis/package-context.h"

namespace verilog {

class PackageContextResolver {
 public:
  // Constructor accepts include resolver for resolving includes within packages
  explicit PackageContextResolver(IncludeFileResolver* include_resolver)
      : include_resolver_(include_resolver) {}

  // Parse a package file and extract its context
  absl::StatusOr<PackageContext> ParsePackage(
      std::string_view package_file);

  // Parse multiple packages and combine their contexts
  absl::StatusOr<CombinedPackageContext> ParsePackages(
      const std::vector<std::string>& package_files);

  // Auto-detect package file based on test file path
  // Example: test_pkg/my_test.sv ‚Üí test_pkg/test_pkg.sv
  absl::StatusOr<std::string> AutoDetectPackageFile(
      std::string_view test_file);

 private:
  IncludeFileResolver* include_resolver_;  // Not owned

  // Extract macro definitions from parsed package
  absl::Status ExtractMacros(
      const verible::TextStructureView& structure,
      PackageContext* context);

  // Extract type definitions (class, typedef, enum names)
  absl::Status ExtractTypes(
      const verible::ConcreteSyntaxTree& tree,
      PackageContext* context);

  // Extract import statements
  absl::Status ExtractImports(
      const verible::ConcreteSyntaxTree& tree,
      PackageContext* context);
};

}  // namespace verilog

#endif
```

**File**: `verible/verilog/analysis/package-context-resolver.cc`

Key implementation points:

1. **ParsePackage**:
   - Create VerilogAnalyzer for package file
   - Use existing PreloadIncludes logic for macros
   - Walk syntax tree to extract type names
   - Return PackageContext

2. **ExtractTypes**:
   - Use verible::SearchSyntaxTree
   - Look for NodeEnum::kClassDeclaration
   - Look for NodeEnum::kTypeDeclaration
   - Extract identifiers

3. **ParsePackages**:
   - Loop through package files
   - Parse each with ParsePackage
   - Merge into CombinedPackageContext
   - Handle duplicates (last one wins)

4. **AutoDetectPackageFile**:
   - Parse directory from test_file
   - Extract directory name (e.g., "test_pkg")
   - Look for <dir>/<dir>_pkg.sv
   - Return path if exists

#### Step 3: Integrate into VerilogAnalyzer

**File**: `verible/verilog/analysis/verilog-analyzer.h`

```cpp
// Add to VerilogAnalyzer class
class VerilogAnalyzer {
 public:
  // ... existing methods ...

  // Feature 3 (v5.4.0): Set package context for parsing
  void SetPackageContext(const CombinedPackageContext& context);

 private:
  // ... existing members ...
  
  // Package context (v5.4.0)
  std::optional<CombinedPackageContext> package_context_;
};
```

**File**: `verible/verilog/analysis/verilog-analyzer.cc`

```cpp
void VerilogAnalyzer::SetPackageContext(
    const CombinedPackageContext& context) {
  package_context_ = context;
}

// In Analyze() method, after creating VerilogPreprocess:
if (package_context_) {
  // Seed macros from package context
  preprocessor.SeedMacroDefinitions(package_context_->all_macros);
  
  // Note: Type seeding into symbol table is future work (v5.5.0)
  // For now, macros are sufficient for most OpenTitan files
}
```

#### Step 4: Add Command-Line Flag

**File**: `verible/verilog/tools/syntax/verilog-syntax.cc`

```cpp
// Add flags
ABSL_FLAG(std::vector<std::string>, package_context, {},
          "Package file(s) to establish context before parsing.\n"
          "Files are processed to extract macros and type definitions,\n"
          "making them available to the target file.\n"
          "Example: --package_context=dv_base_test_pkg.sv");

ABSL_FLAG(bool, auto_detect_package, false,
          "Automatically detect package file based on target file path.\n"
          "Example: test_pkg/my_test.sv ‚Üí looks for test_pkg/test_pkg.sv");

// In main(), after pre-include processing:
// Process package context
const auto package_files = absl::GetFlag(FLAGS_package_context);
const bool auto_detect = absl::GetFlag(FLAGS_auto_detect_package);

CombinedPackageContext combined_context;
if (!package_files.empty() || auto_detect) {
  if (!include_resolver) {
    std::cerr << "Error: --package-context requires --include_paths\n";
    return 1;
  }

  PackageContextResolver pkg_resolver(include_resolver.get());
  
  std::vector<std::string> files_to_parse = package_files;
  
  // Auto-detect if requested
  if (auto_detect && !files.empty()) {
    auto detected = pkg_resolver.AutoDetectPackageFile(files[0]);
    if (detected.ok()) {
      std::cerr << "Auto-detected package: " << *detected << "\n";
      files_to_parse.push_back(*detected);
    }
  }
  
  // Parse packages
  auto context_or = pkg_resolver.ParsePackages(files_to_parse);
  if (!context_or.ok()) {
    std::cerr << "Error parsing package context: " 
              << context_or.status().message() << "\n";
    return 1;
  }
  combined_context = *context_or;
  
  std::cerr << "Loaded package context with " 
            << combined_context.all_macros.size() << " macro(s) and "
            << combined_context.all_types.size() << " type(s)\n";
}

// Pass to analyzer (in AnalyzeOneFile or ParseWithLanguageMode)
if (!combined_context.packages.empty()) {
  analyzer->SetPackageContext(combined_context);
}
```

**Target**: 12/12 tests passing (GREEN phase ‚úÖ)

---

### Phase 3: VALIDATE - OpenTitan Testing (Day 4, 4 hours)

#### Identify Test Files

**Script**: `scripts/identify_package_context_files.sh`

```bash
#!/bin/bash
# Find OpenTitan files that fail without package context

OPENTITAN_ROOT="$1"
RESULTS_DIR="./opentitan_package_test_results"
mkdir -p "$RESULTS_DIR"

echo "Testing OpenTitan files for package context dependency..."

# Test each testbench file
find "$OPENTITAN_ROOT" -name "*_test.sv" | while read test_file; do
  # Extract package name from file path
  dir=$(dirname "$test_file")
  base=$(basename "$dir")
  pkg_file="$dir/${base}_pkg.sv"
  
  if [ -f "$pkg_file" ]; then
    echo "Testing: $test_file with package: $pkg_file"
    
    # Test without package context (should fail)
    ./bazel-bin/verible/verilog/tools/syntax/verible-verilog-syntax \
      --include_paths="$OPENTITAN_ROOT/hw/dv/sv" \
      "$test_file" > /dev/null 2>&1
    without_pkg=$?
    
    # Test with package context (should pass)
    ./bazel-bin/verible/verilog/tools/syntax/verible-verilog-syntax \
      --include_paths="$OPENTITAN_ROOT/hw/dv/sv" \
      --package_context="$pkg_file" \
      "$test_file" > /dev/null 2>&1
    with_pkg=$?
    
    # Record results
    if [ $without_pkg -ne 0 ] && [ $with_pkg -eq 0 ]; then
      echo "‚úÖ FIXED: $test_file" | tee -a "$RESULTS_DIR/fixed.txt"
    elif [ $without_pkg -ne 0 ] && [ $with_pkg -ne 0 ]; then
      echo "‚è≥ STILL_FAILING: $test_file" | tee -a "$RESULTS_DIR/still_failing.txt"
    fi
  fi
done

echo ""
echo "Summary:"
echo "Fixed: $(wc -l < "$RESULTS_DIR/fixed.txt") files"
echo "Still failing: $(wc -l < "$RESULTS_DIR/still_failing.txt") files"
```

#### Validation Goals

- **Target 1**: Identify 14 files that need package context
- **Target 2**: Achieve 14/14 files passing with `--package-context`
- **Target 3**: Overall OpenTitan success: 2,108/2,108 (100%)

---

### Phase 4: DOCS - Documentation (Day 4, 2 hours)

#### Update User Guide

**File**: `VERIPG_UVM_USAGE_EXAMPLES.md`

Add new section:

```markdown
## Example 6: Package Context Mode for OpenTitan

OpenTitan testbenches are designed for package-based compilation. Use package context mode:

### Basic Usage

```bash
verible-verilog-syntax \
  --include_paths=hw/dv/sv \
  --package-context=hw/dv/sv/dv_base_test_pkg.sv \
  hw/dv/sv/my_test.sv
```

### Auto-Detection

```bash
# Automatically finds test_pkg/test_pkg.sv
verible-verilog-syntax \
  --include_paths=hw/dv/sv \
  --auto-detect-package \
  test_pkg/my_test.sv
```

### Multiple Packages

```bash
verible-verilog-syntax \
  --include_paths=hw/dv/sv \
  --package-context=uvm_pkg.sv \
  --package-context=dv_base_test_pkg.sv \
  my_advanced_test.sv
```

### Combined with Pre-Includes

```bash
# Ultimate OpenTitan compatibility
verible-verilog-syntax \
  --include_paths=hw/dv/sv \
  --pre_include=uvm_macros.svh \
  --package-context=dv_base_test_pkg.sv \
  --auto-detect-package \
  my_test.sv
```
```

**File**: `V5.4.0_FEATURE_3_PACKAGE_CONTEXT_GUIDE.md` (comprehensive guide)

---

## üìä Testing Summary

| Test Type | Count | Target | Status |
|-----------|-------|--------|--------|
| Unit Tests | 8 | 8/8 | üéØ TBD |
| Integration Tests | 4 | 4/4 | üéØ TBD |
| OpenTitan Validation | 14 | 14/14 | üéØ TBD |
| **Total** | **26** | **26/26** | **üéØ TBD** |

---

## üéØ Success Criteria

### Functional ‚úÖ

- [ ] Parse package files and extract macros
- [ ] Parse package files and extract type names
- [ ] Multiple packages merge correctly
- [ ] Auto-detect finds package from file path
- [ ] Macro from package available in test file
- [ ] All 26 tests passing

### Quality ‚úÖ

- [ ] Zero regressions
- [ ] Performance: <10% overhead vs no package context
- [ ] Clean error messages for missing packages

### User Experience ‚úÖ

- [ ] Intuitive flag names
- [ ] Helpful error messages
- [ ] Auto-detect "just works"
- [ ] Documentation clear and complete

### OpenTitan ‚úÖ

- [ ] 14 previously failing files now pass
- [ ] Overall: 2,108/2,108 files (100%)

---

## üöÄ Why This is Better Than -D Flags

| Aspect | -D Flags | Package Context |
|--------|----------|-----------------|
| **User Effort** | Must specify each macro | One flag, all context |
| **Accuracy** | Easy to miss macros | Guaranteed complete |
| **Maintenance** | Update flags when macros change | Auto-updates from package |
| **Type Support** | No type context | Type context (future) |
| **OpenTitan Fit** | Workaround | Native workflow |
| **Impact** | Partial solution | **100% solution** |

**Conclusion**: Package Context Mode is the RIGHT solution for OpenTitan UVM testbenches!

---

## üìà Timeline

| Phase | Time | Deliverable |
|-------|------|-------------|
| **RED** | 4 hours | 12 failing tests |
| **GREEN** | 12 hours | 12 passing tests, full implementation |
| **VALIDATE** | 4 hours | 14/14 OpenTitan files passing |
| **DOCS** | 2 hours | Complete documentation |
| **Buffer** | 2 hours | Edge cases, polish |
| **Total** | **24 hours** | **3 days** |

---

## üéâ Expected Outcome

**v5.4.0 will have**:
1. ‚úÖ Feature 1: Better Error Messages (100% DONE)
2. ‚úÖ Feature 2: Pre-Include Support (100% DONE)  
3. ‚úÖ Feature 3: Package Context Mode (NEW - replaces -D flags)

**Result**: **100% OpenTitan success** with elegant, native workflow! üöÄ

---

**Next Step**: Start RED phase - create failing tests for package context! üéØ

